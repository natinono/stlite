<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
    <title>Ambient Viewer</title>
    <script src="https://cdn.jsdelivr.net/npm/@stlite/mountable@0.63.1/build/stlite.js"></script>
  </head>
  <body>
    <div id="root"></div>
    <script>
      stlite.mount(
        {
          requirements: [
            "streamlit",
            "pandas",
            "matplotlib",
            "streamlit-autorefresh",
            "pyodide-http",
            "requests"
          ],
          entrypoint: "streamlit_app.py",
          files: {
            "streamlit_app.py": `
import streamlit as st
import pandas as pd
import numpy as np
import datetime
import pytz
import requests
import matplotlib.pyplot as plt
import matplotlib.font_manager as fm
from streamlit_autorefresh import st_autorefresh
import pyodide_http
import os

# ブラウザでrequestsを使えるようにパッチを適用
pyodide_http.patch_all()

# --- 日本語フォント設定 (japanize-matplotlibの代用) ---
def configure_japanese_font():
    font_url = "https://github.com/googlefonts/noto-cjk/raw/main/Sans/OTF/Japanese/NotoSansCJKjp-Regular.otf"
    font_path = "NotoSansCJKjp-Regular.otf"
    
    # フォントファイルがなければダウンロード
    if not os.path.exists(font_path):
        try:
            response = requests.get(font_url)
            response.raise_for_status()
            with open(font_path, "wb") as f:
                f.write(response.content)
        except Exception as e:
            st.warning(f"日本語フォントのダウンロードに失敗しました: {e}")
            return

    # フォントをMatplotlibに登録
    try:
        fm.fontManager.addfont(font_path)
        plt.rcParams['font.family'] = 'Noto Sans CJK JP'
    except Exception as e:
        st.warning(f"フォントの設定に失敗しました: {e}")

configure_japanese_font()
# -------------------------------------------------------

# Ambientライブラリの代わりとなるクラス
class Ambient:
    def __init__(self, channelId, writeKey=None, readKey=None, userKey=None):
        self.channelId = channelId
        self.readKey = readKey
    
    def read(self, n=None):
        url = f"https://ambidata.io/api/v2/channels/{self.channelId}/data"
        params = {}
        if self.readKey:
            params['readKey'] = self.readKey
        if n:
            params['n'] = n
        
        response = requests.get(url, params=params)
        response.raise_for_status()
        return response.json()

# 自動リフレッシュ設定
count = st_autorefresh(interval=60000, limit=100, key="fizzbuzzcounter")

# 日付パース関数
def parse_date(x):
    try:
        t = datetime.datetime.strptime(x, '%Y-%m-%dT%H:%M:%S.%fZ')
    except ValueError:
        t = datetime.datetime.strptime(x, '%Y-%m-%dT%H:%M:%SZ')
    return pytz.utc.localize(t).astimezone(pytz.timezone('Asia/Tokyo'))

col1, col2 = st.columns(2)

with col1:
    days = st.number_input('表示する日数', 1, 30, 1, step=1)

with col2:
    if st.button('リロード'):
        st.rerun()

try:
    am = Ambient(66341, '', '91fe241f20d21b0e')
    d = am.read(n=int(days * (24 * 60)))
    df = pd.DataFrame(d)

    if df.empty:
        st.error("データが取得できませんでした。(空のデータ)")
    else:
        created = df.pop('created')
        df.insert(0, '日時', created)
        df['日時'] = df['日時'].apply(parse_date)
        df = df.set_index('日時')

        if len(df.columns) == 4:
            df.columns = ['温度','湿度','明るさ','電力']
        elif len(df.columns) == 5:
            df.columns = ['温度','湿度','明るさ','電力','横浜']
        else:
            cols = ['温度','湿度','明るさ','電力','横浜','PC起動','電力料金']
            df.columns = cols[:len(df.columns)]

        for col in df.columns:
            df[col] = pd.to_numeric(df[col], errors='coerce')

        df['不快指数'] = 0.81 * df['温度'] + 0.01 * df['湿度'] * (0.99 * df['温度'] - 14.3 ) + 46.3

        df['電力_'] = df['電力'] * (1/60)
        df['積算電力'] = df.groupby(df.index.date)['電力_'].cumsum()
        df['電気料金'] = df['積算電力'] / 1000 * 31

        latest = df.iloc[-1]
        yokohama_temp = latest['横浜'] if '横浜' in df.columns else '-'
        
        st.write(f"### {df.index[-1].strftime('%m/%d %H:%M')}　外気温{yokohama_temp}℃　室温{latest['温度']}℃　不快指数{int(latest['不快指数'])}")

        fig, (ax1, ax2) = plt.subplots(2, sharex=True, gridspec_kw={'height_ratios': [2, 1], 'hspace': 0}, figsize=(9, 9))
        ax1b = ax1.twinx()
        ax2b = ax2.twinx()

        if '湿度' in df.columns: df['湿度'].plot(ax=ax1, color='lightblue', label='湿度')
        if '不快指数' in df.columns: df['不快指数'].plot(ax=ax1, color='orange', label='不快指数')
        if '横浜' in df.columns: df['横浜'].plot(ax=ax1b, linestyle='--', label='横浜')
        if '温度' in df.columns: df['温度'].plot(ax=ax1b, color='red', label='室温')
        
        if '電力' in df.columns: df['電力'].plot(ax=ax2b, color='orange', label='電力')
        if '明るさ' in df.columns: df['明るさ'].plot(ax=ax2, color='green', label='明るさ')
        if 'PC起動' in df.columns: df['PC起動'].plot(ax=ax2, color='blue', label='PC起動')
        if '電気料金' in df.columns: df['電気料金'].plot(ax=ax2, color='red', label='電気料金')

        ax1.set_ylabel('湿度/不快指数')
        ax1b.set_ylabel('温度')
        ax2.set_ylabel('PC/明るさ/料金')
        ax2b.set_ylabel('電力')

        ax1.grid(False); ax1b.grid(True)
        ax2.grid(False); ax2b.grid(True)
        ax1.xaxis.grid(True); ax2.xaxis.grid(True)

        lines1, labels1 = ax1.get_legend_handles_labels()
        lines1b, labels1b = ax1b.get_legend_handles_labels()
        ax1.legend(lines1 + lines1b, labels1 + labels1b, loc='upper left')

        lines2, labels2 = ax2.get_legend_handles_labels()
        lines2b, labels2b = ax2b.get_legend_handles_labels()
        ax2.legend(lines2 + lines2b, labels2 + labels2b, loc='upper left')

        st.pyplot(fig)
        st.image('https://storage.tenki.jp/storage/static-images/forecaster_diary/image/4/48/482/4828/a/20190604091250/large.jpg', width=250)

except Exception as e:
    st.error(f"エラーが発生しました: {e}")
    st.write("詳細:", e)
`
          }
        },
        document.getElementById("root")
      );
    </script>
  </body>
</html>